Ερώτημα 1.1: Πάρτε τις εγγραφές στις γραμμές 1000 έως 2000 από το tags_stemmed_tokenized_clean_no_stopwords.dat, εξάγετε τις πρώτες τρεις στήλες, ταξινομήστε το αποτέλεσμα αλφαβητικά βάσει της τρίτης στήλης και έπειτα αφαιρέστε τους πρώτους 4 χαρακτήρες από την πρώτη στήλη. Τέλος, εμφανίστε τις πρώτες 5 γραμμές του ταξινομημένου αποτελέσματος (Υπενθύμιση: όλες οι σχετικές εντολές πρέπει να είναι σε μια γραμμή με command chaining). Παράδειγμα output:

628:crime

59501:cs lewi

33838:danc

47382:danc

!head -2000 "/content/drive/My Drive/tags_stemmed_tokenized_clean_no_stopwords.dat" | tail -1001| tr -s : :|rev|cut -f2- -d':'|rev|sort -t':' +2 | cut -c5- | head -5
Σχολιάστε τι κάνει η παραπάνω εντολή ή chained εντολές που δώσατε:

Σε πρώτη φάση, με την εντολή head, παίρνουμε τις πρώτες 2000 γραμμές του αρχείου. Από το αποτέλεσμα που προκύπτει, χρησιμοποιούμε την εντολή tail για να πάρουμε τις τελευταίες 1001 γραμμές του προηγούμενου αποτελέσματος (δηλαδή τις γραμμές 1000-2000). Έπειτα χρησιμοποιώντας το tr(translate) - s μετατρέπουμε τους διπλούς χαρακτήρες ':' σε μονούς. Αντιστρέφουμε τα αποτελέσματα και κάνουμε cut -f2- για να κρατήσουμε από το 2ο πεδίο και μετά και στη συνέχεια αντιστρέφουμε πάλι τα αποτελέσματα (οπότε έχουμε κόψει το τελευταίο πεδίο). Με το sort +2 ορίζουμε ότι το sorting θα γίνει με βάση την 3η στήλη και ότι το διαχωριστικό είναι το ':'. Τέλος κάνουμε πάλι cut για να πάρουμε από τον 5ο χαρακτήρα και μετά και πάλι head -5 για να τυπωθούν τα 5 πρώτα ταξινομημένα αποτελέσματα. Μεταξύ όλων των εντολών χρησιμοποιούμε το '|' για το command chaining καθώς κάθε μία παίρνει ως είσοδο το φιλτραρισμένο αποτέλεσμα της προηγούμενης.

Ερώτημα 1.2: Δημιουργήστε έναν φάκελο με όνομα tag_movies, βρείτε όλες τις ταινίες που περιέχουν τα tags Tarantino ή Jason Statham(χωρίς διάκριση πεζών-κεφαλαίων) από το αρχείο tags_stemmed_tokenized_clean_no_stopwords.dat, αποθηκεύστε τo αποτέλεσμα στον φάκελο tag_movies, σε ένα νέο αρχείο με όνομα matched_tags.txt και δώστε δικαιώματα ανάγνωσης και εγγραφής για το αρχείο αυτό. (Υπενθύμιση: όλες οι σχετικές εντολές πρέπει να είναι σε μια γραμμή με command chaining)

!mkdir tag_movies && grep -i -E "tarantino|jason statham" "/content/drive/My Drive/tags_stemmed_tokenized_clean_no_stopwords.dat" > tag_movies/matched_tags.txt && chmod a=rw tag_movies/matched_tags.txt
Σχολιάστε τι κάνει η παραπάνω εντολή ή chained εντολές που δώσατε:

Σε πρώτη φάση, με την εντολή mkdir δημιουργούμε τον φάκελο tag_movies. Εφόσον γίνει αυτό (&&) χρησιμοποιούμε την εντολή grep για να φιλτράρουμε τα ζητούμενα tags με arguments τα -i (για να μην υπάρχει διάκριση πεζών-κεφαλαίων) και το -E (για να μπορέσουμε να χρησιμοποιήσουμε το | ως λογικό ή). Το αποτέλεσμα του φιλτραρίσματος, το περνάμε σε αρχείο matched_tags.txt μέσα στον φάκελο που δημιουργήσαμε και τέλος δίνουμε δικαιώματα ανάγνωσης και εγγραφής στο αρχείο με την εντολή chmod a=rw(οποιοσδήποτε μπορεί να διαβάσει και να γράψει στο αρχείο). Επαληθέυσαμε τη δημιουργία του φακέλου και του αρχείου απο το Files section του colab στα αριστερά αφού ανοίξαμε το αρχείο, είδαμε τα αποτελέσματα και είχαμε δικαιώματα εγγραφής.

Ερώτημα 1.3: Υπολογίστε το άθροισμα των ratings της ταινίας με MovieD 146.

Βοήθεια: θα χρειαστείτε την paste -sd+ - για να συνδυάσετε τα σχετικά ratings σε ένα addition expression και την bc linux command, για να μπορείτε να κάνετε την πρόσθεση με μη ακέραιους όρους (τα ratings μπορεί να έχουν δεκαδικά μέρη π.χ. 1.5).

!sudo apt-get install bc
!grep '::146::' "/content/drive/My Drive/ratings.dat" | cut -d':' -f5 | paste -sd+ - | bc
Σχολιάστε τι κάνει η παραπάνω εντολή ή chained εντολές που δώσατε:

Από το αρχείο ratings, αρχικά φιλτράρουμε τα αποτελέσματα ώστε να εμφανίζονται μόνο για την ταινία με MovieID:146 και εξάγουμε την 3η στήλη με τα ratings (που αν θεωρήσουμε το ':' ως διαχωριστικό αποτελούν την 5η θέση). Έπειτα χρησιμοποιούμε την εντολή paste -sd+ - που μας δόθηκε, κατά την οποία με το -s ενώνονται όλες οι γραμμές σε μία και με το d+ καθορίζουμε ότι θα ενώνονται με το +. Τέλος χρησιμοποιούμε την bc για να γίνει ο υπολογισμός της πρόσθεσης.

Ερώτημα 1.4: Στο tags_stemmed_tokenized_clean_no_stopwords.dat διαγράψτε τις γραμμές με UserID = 16610 και MovieID=434 και σώστε τη νέα έκδοση του αρχείου ως tags_stemmed_tokenized_clean_no_stopwords.dat2 όπου θα λείπουν μόνο αυτές οι γραμμές.

!grep -v '16610::434::' "/content/drive/My Drive/tags_stemmed_tokenized_clean_no_stopwords.dat" > tags_stemmed_tokenized_clean_no_stopwords.dat2
Σχολιάστε τι κάνει η παραπάνω εντολή ή chained εντολές που δώσατε:

Με την εντολή grep και το argument -v (που είδαμε στην 7η διάλεξη) επιλέγουμε όλες τις γραμμές που ΔΕΝ περιέχουν UserID=16610 και MovieID=434 και τις αποθηκεύουμε στη νέα έκδοση του αρχείου που μας ζητήθηκε. Διευκρίνηση: Από την εκφώνηση καταλάβαμε ότι δεν θέλουμε να εμφανίζονται οι γραμμές που περιέχουν ζευγάρια των ζητούμενων UserIDs-MovieIDs. Αν το ζητούμενο είναι να μην εμφανίζονται γραμμές με αποτελέσματα που είτε έχουν UserID=16610 είτε MovieID=434 είτε και τα δύο τότε θα χρησιμοποιούσαμε την εξής εντολή:

!grep -v -E '^16610::|::434::' "/content/drive/My Drive/tags_stemmed_tokenized_clean_no_stopwords.dat" > tags_stemmed_tokenized_clean_no_stopwords.dat2

Ερώτημα 1.5: Αλλάξτε το tags_stemmed_tokenized_clean_no_stopwords.dat ως εξής: αλλάξτε το tag που έχει δώσει ο χρήστης UserID = 16610 για την ταινία MovieID=434 (μπορεί ο ίδιος χρήστης να έχει δώσει περισσότερα από ένα tag για την ίδια ταινία), αντικαθιστώντας τα tag της 434 με το tag που έχει δώσει ο ίδιο χρήστης για την ταινία με MovieID=741. Προσοχή στο ότι οι όλες οι γραμμές, με εξαίρεση τις 16610::434 που άλλαξαν, θα πρέπει να παραμείνουν ανέπαφες στο αρχείο που θα παραχθεί.

!grep '16610::741::' "/content/drive/My Drive/tags_stemmed_tokenized_clean_no_stopwords.dat" | cut -d':' -f5 > new_tag.txt && grep '16610::434::' "/content/drive/My Drive/tags_stemmed_tokenized_clean_no_stopwords.dat" | cut -d':' -f1-4 > userID_movieID.txt && grep '16610::434::' "/content/drive/My Drive/tags_stemmed_tokenized_clean_no_stopwords.dat" | cut -d':' -f7 > timestamp.txt && yes $(cat new_tag.txt) | head -n $(wc -l < userID_movieID.txt) > repeated_tags.txt && paste -d':' userID_movieID.txt repeated_tags.txt timestamp.txt > new_lines.txt && grep -v '16610::434::' "/content/drive/My Drive/tags_stemmed_tokenized_clean_no_stopwords.dat" > temp_file.txt && cat temp_file.txt new_lines.txt > updated_file.dat
Σχολιάστε τι κάνει η παραπάνω εντολή ή chained εντολές που δώσατε:

Σε πρώτη φάση, κάνουμε extract το tag που έχουμε για το UserID-MovieID pair {16610,741} και το παιρνάμε σε αρχείο new_tag.txt, έπειτα κάνουμε extract το UserID-MovieId pair που μας ενδιαφέρει {16610,434} και το παιρνάμε στο userID_movieID.txt όπως επίσης και το timestamp τους, το οποίο παιρνάμε στο timestamp.txt. Επειδή παρατηρήσαμε ότι έχουμε 1 tag για το {16610,741} και 2 tags για το {16610,434}, χρησιμοποιήσαμε την εντολή yes έτσι ώστε να δημιουργεί μια συνεχόμενη ροή από το new_tag. Με το wc -l < userID_movieID.txt, όπως είδαμε και στη διάλεξη υπολογίζουμε τον αριθμό των γραμμών του αρχέιου και με το head -n $(...) περιορίζουμε την έξοδο της yes στις πρώτες n γραμμές, όπου n είναι ο αριθμός των γραμμών του userID_movieID.txt (αυτό το βρήκαμε online) και το αποθηκέυουμε σε νέο αρχείο repeated_tags.txt. Στη συνέχεια, με το paste -d':' συνδυάζουμε τις γραμμές από τα 3 αρχεία και τα αποθηκέυουμε στο νέο αρχείο new_lines.txt. Έπειτα, αφαιρούμε τις 2 παλιές γραμμές του συνδυασμού {16610,434} από το αρχικό file και παιρνάμε το υπόλοιπο ως έχει σε νέο file temp_file.txt. Τέλος, χρησιμοποιούμε την εντολή cat και τα 2 files (το αρχικό χωρις τις 2 εγγραφές για το {16610,434} και αυτό με τις 2 νέες γραμμές) και τα αποθηκεύουμε στο αρχείο updated_file.dat. Πράγματι, όπως φαίνεται και παρακάτω, τρέξαμε την εντολή !diff και επαληθεύσαμε ότι η μόνη διαφορά του αρχικού αρχείου με το νέο είναι οι 2 αυτές γραμμές που μας ζητήθηκε να αλλάξουμε το tag τους.

Ερώτημα 1.6: Αλλάξτε το tags_stemmed_tokenized_clean_no_stopwords.dat ως εξής: αντικαταστήσε την 4η στήλη με αριθμητικές τιμές που θα ξεκινούν από το 01 και θα αυξάνονται ανά 3 σε κάθε γραμμή (δεν μπορείτε να υποθέσετε πως ξέρετε εκ των προτέρων τον αριθμό των γραμμών του αρχείου). Γράψτε το αποτέλεσμα σε νέο αρχείο tags_stemmed_tokenized_clean_no_stopwords.dat3

!seq -w 1 3 $(($(wc -l < "/content/drive/My Drive/tags_stemmed_tokenized_clean_no_stopwords.dat") * 3)) > num_sequence.txt && cut -d':' -f1-5 "/content/drive/My Drive/tags_stemmed_tokenized_clean_no_stopwords.dat" > first_columns.txt && paste -d':' first_columns.txt num_sequence.txt > tags_stemmed_tokenized_clean_no_stopwords.dat3
Σχολιάστε τι κάνει η παραπάνω εντολή ή chained εντολές που δώσατε:

Χρησιμοποιούμε την εντολή seq για να δημιουργήσουμε την ακολουθία αριθμών με αρχή το 1, βήμα 3 και ανώτατο όριο το σύνολο των γραμμών στο αρχείο πολλαπλασιασμένο με το 3. Χρησιμοποιούμε το -w για να έχουμε σταθερό πλάτος ακολουθίας (δηλ. αντί 1,4,... θα έχουμε 00001,00004, ...., τόσα μηδενικά όσα ψηφία έχουμε στο τέλος της ακολουθίας) και αποθηκεύουμε την ακολουθία στο αρχείο num_sequence.txt. Έπειτα κάνουμε cut για να πάρουμε τις 3 πρώτες στήλες απο το αρχικό αρχείο και τις αποθηκεύουμε σε νέο αρχείο first_columns.txt. Τέλος με το paste, συνδυάζουμε τα 2 νέα αρχεία και δημιουργούμε το ζητούμενο tags_stemmed_tokenized_clean_no_stopwords.dat3